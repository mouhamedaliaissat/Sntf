import os
import logging
from datetime import datetime, timedelta
import pytz
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ApplicationBuilder, ContextTypes, CommandHandler, CallbackQueryHandler
from schedules import go_schedule, return_schedule
from pymongo import MongoClient, errors
import asyncio

# Set up logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Set Algerian time zone
ALGERIA_TZ = pytz.timezone('Africa/Algiers')

# Constants
DIRECTION_GO = "go"
DIRECTION_RETURN = "return"
# Emojis for rating
UPVOTE_EMOJI = "‚úÖ"
DOWNVOTE_EMOJI = "‚ùå"

# MongoDB setup
MONGODB_URI = os.getenv("MONGODB_URI")
DB_NAME = "train_bot"
COLLECTION_NAME = "reports"

# Initialize MongoDB client with error handling
client = None
reports_collection = None
MONGO_AVAILABLE = False

def init_mongodb():
    global client, reports_collection, MONGO_AVAILABLE
    logger.info("üîß Starting MongoDB initialization...")
    if not MONGODB_URI:
        logger.error("‚ùå MONGODB_URI environment variable not set")
        return False
    try:
        logger.info(f"üîß Attempting to connect to MongoDB...")
        logger.info(f"üîó URI: {MONGODB_URI[:30]}...{MONGODB_URI[-20:] if len(MONGODB_URI) > 50 else MONGODB_URI}")
        logger.info(f"MONGODB_URI is: {MONGODB_URI}")
        # Create client with timeout settings
        client = MongoClient(
            MONGODB_URI,
            serverSelectionTimeoutMS=5000,
            connectTimeoutMS=5000,
            socketTimeoutMS=5000
        )
        # Test the connection
        logger.info("üîç Testing MongoDB connection...")
        client.admin.command('ping')
        logger.info("‚úÖ MongoDB ping successful")
        # Access database and collection
        db = client[DB_NAME]
        reports_collection = db[COLLECTION_NAME]
        logger.info(f"üìö Using database: {DB_NAME}, collection: {COLLECTION_NAME}")
        # Test insert to verify everything works
        test_doc = {
            "test": "connection",
            "time": datetime.now().timestamp(),
            "source": "bot_initialization"
        }
        logger.info("üìù Testing document insertion...")
        result = reports_collection.insert_one(test_doc)
        logger.info(f"‚úÖ Test document inserted with ID: {result.inserted_id}")
        # Clean up test document
        reports_collection.delete_one({"_id": result.inserted_id})
        logger.info("üßπ Test document cleaned up")
        MONGO_AVAILABLE = True
        logger.info("üéâ MongoDB initialization completed successfully")
        return True
    except errors.ServerSelectionTimeoutError as e:
        logger.error(f"‚ùå MongoDB connection timeout: {e}")
        logger.error("üí° Check your internet connection and MongoDB URI")
    except errors.ConnectionFailure as e:
        logger.error(f"‚ùå MongoDB connection failure: {e}")
        logger.error("üí° Check if MongoDB Atlas cluster is running")
    except errors.ConfigurationError as e:
        logger.error(f"‚ùå MongoDB configuration error: {e}")
        logger.error("üí° Check your MongoDB URI format")
    except errors.AuthenticationFailed as e:
        logger.error(f"‚ùå MongoDB authentication failed: {e}")
        logger.error("üí° Check your username and password")
    except Exception as e:
        logger.error(f"‚ùå Unexpected error during MongoDB initialization: {e}")
        logger.exception(e)
    return False

# Initialize MongoDB on startup
logger.info("üöÄ Initializing MongoDB connection...")
MONGO_AVAILABLE = init_mongodb()
logger.info(f"üìä MongoDB Status: {'üü¢ Available' if MONGO_AVAILABLE else 'üî¥ Not Available'}")

# Function to get all unique stations preserving order from schedules
def get_all_stations_ordered():
    logger.info("üìã Getting all stations in order...")
    go_stations = list(go_schedule.keys())
    return_stations = list(return_schedule.keys())
    all_stations = []
    seen = set()
    # Add stations from go_schedule first
    for station in go_stations:
        if station not in seen:
            all_stations.append(station)
            seen.add(station)
    # Add stations from return_schedule
    for station in return_stations:
        if station not in seen:
            all_stations.append(station)
            seen.add(station)
    logger.info(f"üìä Total stations found: {len(all_stations)}")
    return all_stations

def get_algerian_time():
    return datetime.now(ALGERIA_TZ)

def save_report_to_db(report_data):
    logger.info(f"üíæ Attempting to save report to database: {report_data}")
    try:
        # Ensure user_ratings dict exists
        if "user_ratings" not in report_data:
            report_data["user_ratings"] = {}
        if "upvotes" not in report_data:
            report_data["upvotes"] = 0
        if "downvotes" not in report_data:
            report_data["downvotes"] = 0
            
        if reports_collection is not None:
            logger.info("üì§ Inserting document into MongoDB...")
            result = reports_collection.insert_one(report_data)
            logger.info(f"‚úÖ Report saved successfully with ID: {result.inserted_id}")
            return True
        else:
            logger.warning("‚ö†Ô∏è MongoDB collection not available for saving")
            return False
    except Exception as e:
        logger.error(f"‚ùå Error saving report to MongoDB: {e}")
        logger.exception(e)
        return False

def get_all_reports_from_db():
    logger.info("üì• Retrieving all reports from database...")
    try:
        if reports_collection is not None:
            reports = list(reports_collection.find())
            logger.info(f"üìä Retrieved {len(reports)} reports from database")
            return reports
        else:
            logger.warning("‚ö†Ô∏è MongoDB collection not available for reading")
            return []
    except Exception as e:
        logger.error(f"‚ùå Error getting reports from MongoDB: {e}")
        logger.exception(e)
        return []

def get_reports_by_station_from_db(station):
    logger.info(f"üì• Retrieving reports for station: {station}")
    try:
        if reports_collection is not None:
            # Get today's date in Algeria timezone
            today = datetime.now(ALGERIA_TZ).date()
            # Create datetime objects for start and end of today
            start_of_day = datetime.combine(today, datetime.min.time()).replace(tzinfo=ALGERIA_TZ)
            end_of_day = datetime.combine(today, datetime.max.time()).replace(tzinfo=ALGERIA_TZ)
            
            reports = list(reports_collection.find({
                "station": station,
                "timestamp": {
                    "$gte": start_of_day.timestamp(),
                    "$lte": end_of_day.timestamp()
                }
            }))
            logger.info(f"üìä Retrieved {len(reports)} reports for station {station} on {today}")
            return reports
        else:
            logger.warning("‚ö†Ô∏è MongoDB collection not available for reading")
            return []
    except Exception as e:
        logger.error(f"‚ùå Error getting reports by station from MongoDB: {e}")
        logger.exception(e)
        return []

# --- NEW RATING FUNCTIONS ---
def has_user_rated(report_id, user_id):
    """Check if a user has already rated a report."""
    try:
        if reports_collection is not None:
            from bson import ObjectId
            report = reports_collection.find_one(
                {"_id": ObjectId(report_id)},
                {"user_ratings": 1} # Only fetch the user_ratings field
            )
            if report and "user_ratings" in report:
                return str(user_id) in report["user_ratings"]
        return False
    except Exception as e:
        logger.error(f"‚ùå Error checking user rating: {e}")
        logger.exception(e)
        return False # Assume not rated on error

def get_user_rating(report_id, user_id):
    """Get a user's specific rating for a report."""
    try:
        if reports_collection is not None:
            from bson import ObjectId
            report = reports_collection.find_one(
                {"_id": ObjectId(report_id)},
                {"user_ratings": 1}
            )
            if report and "user_ratings" in report:
                return report["user_ratings"].get(str(user_id))
        return None
    except Exception as e:
        logger.error(f"‚ùå Error getting user rating: {e}")
        logger.exception(e)
        return None

def update_rating_in_db(report_id, user_id, new_rating):
    """
    Update a user's rating for a report and adjust vote counts.
    new_rating: 'up' or 'down'
    """
    logger.info(f"üó≥Ô∏è Updating rating for report {report_id} by user {user_id} to '{new_rating}'")
    try:
        if reports_collection is not None:
            from bson import ObjectId
            if not ObjectId.is_valid(report_id):
                logger.error(f"‚ùå Invalid ObjectId format: {report_id}")
                return False

            # Get the current rating for the user (if any)
            current_rating = get_user_rating(report_id, user_id)
            logger.info(f"   Current rating for user {user_id}: {current_rating}")

            # Prepare update operations
            update_ops = {
                "$set": {f"user_ratings.{user_id}": new_rating}
            }

            # Adjust vote counts based on the change
            vote_updates = {}
            if current_rating == 'up' and new_rating == 'down':
                # Change from up to down
                vote_updates["upvotes"] = -1
                vote_updates["downvotes"] = 1
            elif current_rating == 'down' and new_rating == 'up':
                # Change from down to up
                vote_updates["upvotes"] = 1
                vote_updates["downvotes"] = -1
            elif current_rating is None and new_rating == 'up':
                # New upvote
                vote_updates["upvotes"] = 1
            elif current_rating is None and new_rating == 'down':
                # New downvote
                vote_updates["downvotes"] = 1
            # If current_rating == new_rating, no change needed for votes

            if vote_updates:
                update_ops["$inc"] = vote_updates

            logger.info(f"   Update operations: {update_ops}")

            result = reports_collection.update_one(
                {"_id": ObjectId(report_id)},
                update_ops
            )
            if result.modified_count > 0:
                logger.info(f"‚úÖ Successfully updated rating for report {report_id}")
                return True
            else:
                logger.warning(f"‚ö†Ô∏è No report found or no change for rating on report {report_id}")
                return False
        else:
            logger.warning("‚ö†Ô∏è MongoDB collection not available for updating ratings")
            return False
    except Exception as e:
        logger.error(f"‚ùå Error updating rating in MongoDB: {e}")
        logger.exception(e)
        return False

# Debug command
async def debug_db(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Debug command to check database status"""
    logger.info("üîç Debug command received")
    if not MONGO_AVAILABLE:
        response = "‚ùå MongoDB not available\n"
        response += "Check Railway logs for connection errors"
        await update.message.reply_text(response)
        logger.warning("‚ö†Ô∏è Debug command: MongoDB not available")
        return
    try:
        logger.info("üîç Performing debug checks...")
        # Check connection
        logger.info("üîç Testing MongoDB connection...")
        client.admin.command('ping')
        logger.info("‚úÖ MongoDB connection test successful")
        # Get database info
        logger.info("üîç Getting database information...")
        db_names = client.list_database_names()
        logger.info(f"üìä Available databases: {db_names}")
        collection_names = reports_collection.database.list_collection_names()
        logger.info(f"üìÇ Available collections: {collection_names}")
        # Get report count
        logger.info("üîç Counting reports...")
        report_count = reports_collection.count_documents({})
        logger.info(f"üìà Total reports in database: {report_count}")
        # Get sample reports
        logger.info("üîç Getting sample reports...")
        sample_reports = list(reports_collection.find().limit(3))
        logger.info(f"üìã Sample reports retrieved: {len(sample_reports)}")
        response = "‚úÖ Database Debug Information:\n"
        response += f"üìä Databases: {db_names}\n"
        response += f"üìÇ Collections: {collection_names}\n"
        response += f"üìà Total Reports: {report_count}\n"
        if sample_reports:
            response += "üìã Recent Reports:\n"
            for i, report in enumerate(sample_reports[:3]):
                response += f"{i+1}. {report.get('station', 'N/A')} - {report.get('direction', 'N/A')} - {report.get('time', 'N/A')}\n"
        else:
            response += "üì≠ No reports found\n"
        response += "üîß MongoDB Status: Connected ‚úÖ"
        await update.message.reply_text(response)
        logger.info("‚úÖ Debug command completed successfully")
    except Exception as e:
        logger.error(f"‚ùå Debug command error: {e}")
        logger.exception(e)
        await update.message.reply_text(f"‚ùå Database Error: {str(e)}")

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    logger.info("üè† Start command received")
    keyboard = [
        [InlineKeyboardButton("üöÜ ÿßŸÑÿ¨ÿ≤ÿßÿ¶ÿ± ÿßŸÑŸâ ÿßŸÑÿπŸÅÿ±ŸàŸÜ", callback_data="direction_go")],
        [InlineKeyboardButton("üöÜ ÿßŸÑÿπŸÅÿ±ŸàŸÜ ÿßŸÑŸâ ÿßŸÑÿ¨ÿ≤ÿßÿ¶ÿ±", callback_data="direction_return")],
        [InlineKeyboardButton("üìä ÿ•ÿ®ŸÑÿßÿ∫ ÿ®ŸàÿµŸàŸÑ ŸÇÿ∑ÿßÿ±", callback_data="report_train")],
        [InlineKeyboardButton("üìã ÿπÿ±ÿ∂ ÿßŸÑÿ™ŸÇÿßÿ±Ÿäÿ±", callback_data="view_reports")]
    ]
    if update.message:
        await update.message.reply_text("üëã ŸÖÿ±ÿ≠ÿ®Ÿãÿß ÿ®ŸÉ! ÿßÿÆÿ™ÿ± ÿÆŸäÿßÿ±Ÿãÿß:", reply_markup=InlineKeyboardMarkup(keyboard))
    else:
        await update.callback_query.edit_message_text("üëã ŸÖÿ±ÿ≠ÿ®Ÿãÿß ÿ®ŸÉ! ÿßÿÆÿ™ÿ± ÿÆ_optionŸãÿß:", reply_markup=InlineKeyboardMarkup(keyboard))

async def handle_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        query = update.callback_query
        await query.answer()
        logger.info(f"üéÆ Callback received: {query.data}")
        user_id = str(query.from_user.id) # Get the user ID who clicked the button
        data = query.data

        # --- NEW RATING FUNCTIONALITY ---
        # Handle upvote
        if data.startswith("rate_up_"):
            report_id = data.split("_", 2)[2]
            logger.info(f"üëç User {user_id} rated report {report_id} as up")
            
            # Update rating in DB
            success = update_rating_in_db(report_id, user_id, 'up')
            if success:
                await query.answer("ÿ™ŸÖ ÿßŸÑÿ™ŸÇŸäŸäŸÖ ÿ®ŸÄ ‚úÖ")
                # Refresh the view by re-triggering the view_station callback
                # Find the station for this report
                try:
                    from bson import ObjectId
                    report = reports_collection.find_one({"_id": ObjectId(report_id)}, {"station": 1})
                    if report and "station" in report:
                        # Re-display the station reports view
                        data = f"view_station_{report['station']}"
                        # Fall through to the view_station handler below
                    else:
                        await query.answer("ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ŸÅŸä ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿ™ÿµŸàŸäÿ™.")
                        return
                except Exception as e:
                    logger.error(f"Error finding report for refresh: {e}")
                    await query.answer("ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ŸÅŸä ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿ™ÿµŸàŸäÿ™.")
                    return
            else:
                await query.answer("ŸÅÿ¥ŸÑ ŸÅŸä ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿ™ÿµŸàŸäÿ™.")
                return

        # Handle downvote
        elif data.startswith("rate_down_"):
            report_id = data.split("_", 3)[2]
            logger.info(f"üëé User {user_id} rated report {report_id} as down")
            
            # Update rating in DB
            success = update_rating_in_db(report_id, user_id, 'down')
            if success:
                await query.answer("ÿ™ŸÖ ÿßŸÑÿ™ŸÇŸäŸäŸÖ ÿ®ŸÄ ‚ùå")
                # Refresh the view
                try:
                    from bson import ObjectId
                    report = reports_collection.find_one({"_id": ObjectId(report_id)}, {"station": 1})
                    if report and "station" in report:
                        data = f"view_station_{report['station']}"
                    else:
                        await query.answer("ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ŸÅŸä ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿ™ÿµŸàŸäÿ™.")
                        return
                except Exception as e:
                    logger.error(f"Error finding report for refresh: {e}")
                    await query.answer("ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ŸÅŸä ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿ™ÿµŸàŸäÿ™.")
                    return
            else:
                await query.answer("ŸÅÿ¥ŸÑ ŸÅŸä ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿ™ÿµŸàŸäÿ™.")
                return
        # --- END NEW RATING FUNCTIONALITY ---

        # Report Train Arrival
        if data == "report_train":
            logger.info("üìù User selected to report train arrival")
            stations = get_all_stations_ordered()
            logger.info(f"üìä Showing {len(stations)} stations for reporting")
            station_buttons = []
            for i in range(0, len(stations), 2):
                row = []
                row.append(InlineKeyboardButton(stations[i], callback_data=f"report_station_{stations[i]}"))
                if i + 1 < len(stations):
                    row.append(InlineKeyboardButton(stations[i + 1], callback_data=f"report_station_{stations[i + 1]}"))
                station_buttons.append(row)
            station_buttons.append([InlineKeyboardButton("‚¨ÖÔ∏è ÿßŸÑÿπŸàÿØÿ©", callback_data="back_to_start")])
            await query.edit_message_text("üìç ÿßÿÆÿ™ÿ± ÿßŸÑŸÖÿ≠ÿ∑ÿ© ÿßŸÑÿ™Ÿä ŸàÿµŸÑ ÿ•ŸÑŸäŸáÿß ÿßŸÑŸÇÿ∑ÿßÿ±:", reply_markup=InlineKeyboardMarkup(station_buttons))
            return

        elif data.startswith("report_station_"):
            station = data.split("_", 2)[2]
            context.user_data["report_station"] = station
            logger.info(f"üìç User selected station: {station}")
            keyboard = [
                [InlineKeyboardButton("üöÜ ÿßŸÑÿ¨ÿ≤ÿßÿ¶ÿ± ÿßŸÑŸâ ÿßŸÑÿπŸÅÿ±ŸàŸÜ", callback_data="report_direction_go")],
                [InlineKeyboardButton("üöÜ ÿßŸÑÿπŸÅÿ±ŸàŸÜ ÿßŸÑŸâ ÿßŸÑÿ¨ÿ≤ÿßÿ¶ÿ±", callback_data="report_direction_return")],
                [InlineKeyboardButton("‚¨ÖÔ∏è ÿßŸÑÿπŸàÿØÿ©", callback_data="back_to_start")]
            ]
            await query.edit_message_text(f"üìç ÿßŸÑŸÖÿ≠ÿ∑ÿ©: {station}\nÿßÿÆÿ™ÿ± ÿßÿ™ÿ¨ÿßŸá ÿßŸÑŸÇÿ∑ÿßÿ±:", reply_markup=InlineKeyboardMarkup(keyboard))
            return

        elif data == "report_direction_go":
            station = context.user_data.get("report_station")
            direction = DIRECTION_GO
            logger.info(f"üì§ Saving report - Station: {station}, Direction: {direction}, User: {user_id}")
            alg_time = get_algerian_time()
            report = {
                "station": station,
                "direction": direction,
                "time": alg_time.strftime('%Y-%m-%d %H:%M:%S'),
                "timestamp": alg_time.timestamp(),
                "user_ratings": {},  # Initialize user ratings
                "upvotes": 0,
                "downvotes": 0
            }
            logger.info(f"üìù Report data: {report}")
            success = save_report_to_db(report)
            if success:
                response_text = f"‚úÖ ÿ™ŸÖ ÿ≠ŸÅÿ∏ ÿßŸÑÿ™ŸÇÿ±Ÿäÿ±!\nüìç ÿßŸÑŸÖÿ≠ÿ∑ÿ©: {station}\nüß≠ ÿßŸÑÿßÿ™ÿ¨ÿßŸá: ÿßŸÑÿ¨ÿ≤ÿßÿ¶ÿ± ÿßŸÑŸâ ÿßŸÑÿπŸÅÿ±ŸàŸÜ\nüïê ÿßŸÑŸàŸÇÿ™: {report['time']}"
                logger.info(f"üéâ Report saved successfully for {station} by user {user_id}")
            else:
                response_text = f"‚ùå ŸÅÿ¥ŸÑ ÿ≠ŸÅÿ∏ ÿßŸÑÿ™ŸÇÿ±Ÿäÿ±!\nüìç ÿßŸÑŸÖÿ≠ÿ∑ÿ©: {station}\nüß≠ ÿßŸÑÿßÿ™ÿ¨ÿßŸá: ÿßŸÑÿ¨ÿ≤ÿßÿ¶ÿ± ÿßŸÑŸâ ÿßŸÑÿπŸÅÿ±ŸàŸÜ\nüïê ÿßŸÑŸàŸÇÿ™: {report['time']}\n‚ö†Ô∏è ŸÖÿ¥ŸÉŸÑÿ© ŸÅŸä ÿßŸÑÿßÿ™ÿµÿßŸÑ ÿ®ŸÇÿßÿπÿØÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™"
                logger.error(f"üí• Failed to save report for {station}")
            await query.edit_message_text(response_text)
            await asyncio.sleep(3)
            await start(update, context)
            return

        elif data == "report_direction_return":
            station = context.user_data.get("report_station")
            direction = DIRECTION_RETURN
            logger.info(f"üì§ Saving report - Station: {station}, Direction: {direction}, User: {user_id}")
            alg_time = get_algerian_time()
            report = {
                "station": station,
                "direction": direction,
                "time": alg_time.strftime('%Y-%m-%d %H:%M:%S'),
                "timestamp": alg_time.timestamp(),
                "user_ratings": {},  # Initialize user ratings
                "upvotes": 0,
                "downvotes": 0
            }
            logger.info(f"üìù Report data: {report}")
            success = save_report_to_db(report)
            if success:
                response_text = f"‚úÖ ÿ™ŸÖ ÿ≠ŸÅÿ∏ ÿßŸÑÿ™ŸÇÿ±Ÿäÿ±!\nüìç ÿßŸÑŸÖÿ≠ÿ∑ÿ©: {station}\nüß≠ ÿßŸÑÿßÿ™ÿ¨ÿßŸá: ÿßŸÑÿπŸÅÿ±ŸàŸÜ ÿßŸÑŸâ ÿßŸÑÿ¨ÿ≤ÿßÿ¶ÿ±\nüïê ÿßŸÑŸàŸÇÿ™: {report['time']}"
                logger.info(f"üéâ Report saved successfully for {station} by user {user_id}")
            else:
                response_text = f"‚ùå ŸÅÿ¥ŸÑ ÿ≠ŸÅÿ∏ ÿßŸÑÿ™ŸÇÿ±Ÿäÿ±!\nüìç ÿßŸÑŸÖÿ≠ÿ∑ÿ©: {station}\nüß≠ ÿßŸÑÿßÿ™ÿ¨ÿßŸá: ÿßŸÑÿπŸÅÿ±ŸàŸÜ ÿßŸÑŸâ ÿßŸÑÿ¨ÿ≤ÿßÿ¶ÿ±\nüïê ÿßŸÑŸàŸÇÿ™: {report['time']}\n‚ö†Ô∏è ŸÖÿ¥ŸÉŸÑÿ© ŸÅŸä ÿßŸÑÿßÿ™ÿµÿßŸÑ ÿ®ŸÇÿßÿπÿØÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™"
                logger.error(f"üí• Failed to save report for {station}")
            await query.edit_message_text(response_text)
            await asyncio.sleep(3)
            await start(update, context)
            return

        # View Reports
        elif data == "view_reports":
            logger.info("üìã User requested to view reports")
            if not MONGO_AVAILABLE:
                response = "‚ùå ŸÇÿßÿπÿØÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿ∫Ÿäÿ± ŸÖÿ™ŸàŸÅÿ±ÿ© ÿ≠ÿßŸÑŸäÿßŸã."
                keyboard = [[InlineKeyboardButton("‚¨ÖÔ∏è ÿßŸÑÿπŸàÿØÿ©", callback_data="back_to_start")]]
                await query.edit_message_text(response, reply_markup=InlineKeyboardMarkup(keyboard))
                logger.warning("‚ö†Ô∏è View reports: MongoDB not available")
                return
            reports = get_all_reports_from_db()
            logger.info(f"üìä Found {len(reports)} total reports")
            if not reports:
                response = "‚ùå ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ™ŸÇÿßÿ±Ÿäÿ± ŸÖÿ≠ŸÅŸàÿ∏ÿ©."
                keyboard = [[InlineKeyboardButton("‚¨ÖÔ∏è ÿßŸÑÿπŸàÿØÿ©", callback_data="back_to_start")]]
                await query.edit_message_text(response, reply_markup=InlineKeyboardMarkup(keyboard))
                return
            stations_with_reports = {}
            for report in reports:
                station = report["station"]
                if station not in stations_with_reports:
                    stations_with_reports[station] = []
                stations_with_reports[station].append(report)
            all_stations = get_all_stations_ordered()
            station_buttons = []
            stations_with_reports_ordered = [station for station in all_stations if station in stations_with_reports]
            logger.info(f"üìä Stations with reports: {len(stations_with_reports_ordered)}")
            if not stations_with_reports_ordered:
                response = "‚ùå ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ™ŸÇÿßÿ±Ÿäÿ± ŸÖÿ≠ŸÅŸàÿ∏ÿ©."
                keyboard = [[InlineKeyboardButton("‚¨ÖÔ∏è ÿßŸÑÿπŸàÿØÿ©", callback_data="back_to_start")]]
                await query.edit_message_text(response, reply_markup=InlineKeyboardMarkup(keyboard))
                return
            for i in range(0, len(stations_with_reports_ordered), 2):
                row = []
                station1 = stations_with_reports_ordered[i]
                report_count1 = len(stations_with_reports[station1])
                row.append(InlineKeyboardButton(f"üìç {station1} ({report_count1})", callback_data=f"view_station_{station1}"))
                if i + 1 < len(stations_with_reports_ordered):
                    station2 = stations_with_reports_ordered[i + 1]
                    report_count2 = len(stations_with_reports[station2])
                    row.append(InlineKeyboardButton(f"üìç {station2} ({report_count2})", callback_data=f"view_station_{station2}"))
                station_buttons.append(row)
            station_buttons.append([InlineKeyboardButton("‚¨ÖÔ∏è ÿßŸÑÿπŸàÿØÿ©", callback_data="back_to_start")])
            await query.edit_message_text("üìã ÿßÿÆÿ™ÿ± ŸÖÿ≠ÿ∑ÿ© ŸÑÿπÿ±ÿ∂ ÿßŸÑÿ™ŸÇÿßÿ±Ÿäÿ±:", reply_markup=InlineKeyboardMarkup(station_buttons))
            return

        elif data.startswith("view_station_"):
            selected_station = data.split("_", 2)[2]
            logger.info(f"üîç User viewing reports for station: {selected_station}")
            if not MONGO_AVAILABLE:
                response = "‚ùå ŸÇÿßÿπÿØÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿ∫Ÿäÿ± ŸÖÿ™ŸàŸÅÿ±ÿ© ÿ≠ÿßŸÑŸäÿßŸã."
                keyboard = [[InlineKeyboardButton("‚¨ÖÔ∏è ÿßŸÑÿπŸàÿØÿ©", callback_data="back_to_start")]]
                await query.edit_message_text(response, reply_markup=InlineKeyboardMarkup(keyboard))
                return
            station_reports = get_reports_by_station_from_db(selected_station)
            if not station_reports:
                response = f"‚ùå ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ™ŸÇÿßÿ±Ÿäÿ± ŸÑŸÑŸÖÿ≠ÿ∑ÿ©: {selected_station}"
            else:
                response = f"üìã ÿ™ŸÇÿßÿ±Ÿäÿ± ÿßŸÑŸÖÿ≠ÿ∑ÿ©: {selected_station}\n\n"
                # Sort by timestamp (newest first) and show last 10
                sorted_reports = sorted(station_reports, key=lambda x: x["timestamp"], reverse=True)[:10]
                keyboard = [] # Initialize keyboard for inline buttons

                for i, report in enumerate(sorted_reports):
                    direction_text = "ÿßŸÑÿ¨ÿ≤ÿßÿ¶ÿ± ÿßŸÑŸâ ÿßŸÑÿπŸÅÿ±ŸàŸÜ" if report["direction"] == DIRECTION_GO else "ÿßŸÑÿπŸÅÿ±ŸàŸÜ ÿßŸÑŸâ ÿßŸÑÿ¨ÿ≤ÿßÿ¶ÿ±"
                    upvotes = report.get("upvotes", 0)
                    downvotes = report.get("downvotes", 0)
                    report_id = str(report['_id'])
                    
                    # Format time to HH:MM only
                    report_time_obj = datetime.fromtimestamp(report['timestamp'], ALGERIA_TZ)
                    formatted_time = report_time_obj.strftime('%H:%M')
                    
                    response += f"{i+1}. üß≠ {direction_text}\n   üïê {formatted_time}\n"

                    # Check if user has already rated this report
                    user_rating = get_user_rating(report_id, user_id)
                    
                    if user_rating is not None:
                        # User has rated, show their rating
                        rating_emoji = UPVOTE_EMOJI if user_rating == 'up' else DOWNVOTE_EMOJI
                        response += f"   (ÿ™ŸÖ ÿßŸÑÿ™ŸÇŸäŸäŸÖ ÿ®ŸÄ {rating_emoji})\n"
                    else:
                        # User hasn't rated, show rating buttons
                        keyboard.append([
                            InlineKeyboardButton(f"{UPVOTE_EMOJI} ({upvotes})", callback_data=f'rate_up_{report_id}'),
                            InlineKeyboardButton(f"{DOWNVOTE_EMOJI} ({downvotes})", callback_data=f'rate_down_{report_id}')
                        ])
                    response += "\n" # Add space after each report block

                # Add navigation buttons at the end
                keyboard.append([InlineKeyboardButton("üìã ÿπÿ±ÿ∂ ŸÖÿ≠ÿ∑ÿßÿ™ ÿ£ÿÆÿ±Ÿâ", callback_data="view_reports")])
                keyboard.append([InlineKeyboardButton("‚¨ÖÔ∏è ÿßŸÑÿπŸàÿØÿ©", callback_data="back_to_start")])

            await query.edit_message_text(response, reply_markup=InlineKeyboardMarkup(keyboard))
            return

        # Original functionality
        elif data == "direction_go":
            context.user_data["direction"] = DIRECTION_GO
            stations = list(go_schedule.keys())
            station_buttons = [
                [InlineKeyboardButton(station, callback_data=f"station_{station}")]
                for station in stations
            ]
            station_buttons.append([InlineKeyboardButton("‚¨ÖÔ∏è ÿßŸÑÿπŸàÿØÿ©", callback_data="back_to_start")])
            await query.edit_message_text("üìç ÿßÿÆÿ™ÿ± ŸÖÿ≠ÿ∑ÿ™ŸÉ:", reply_markup=InlineKeyboardMarkup(station_buttons))
            return

        elif data == "direction_return":
            context.user_data["direction"] = DIRECTION_RETURN
            stations = list(return_schedule.keys())
            station_buttons = [
                [InlineKeyboardButton(station, callback_data=f"station_{station}")]
                for station in stations
            ]
            station_buttons.append([InlineKeyboardButton("‚¨ÖÔ∏è ÿßŸÑÿπŸàÿØÿ©", callback_data="back_to_start")])
            await query.edit_message_text("üìç ÿßÿÆÿ™ÿ± ŸÖÿ≠ÿ∑ÿ™ŸÉ:", reply_markup=InlineKeyboardMarkup(station_buttons))
            return

        elif data == "back_to_start":
            await start(update, context)
            return

        elif data == "show_all_trains":
            station = context.user_data.get("last_station")
            direction = context.user_data.get("direction")
            if direction == DIRECTION_GO:
                schedule = go_schedule.get(station, [])
                destination = "ÿßŸÑÿπŸÅÿ±ŸàŸÜ"
            else:
                schedule = return_schedule.get(station, [])
                destination = "ÿßŸÑÿ¨ÿ≤ÿßÿ¶ÿ±"
            now = get_algerian_time().time()

            def str_to_time(s):
                return datetime.strptime(s, "%H:%M").time()

            future_trains = [t for t in schedule if str_to_time(t) > now]
            if future_trains:
                train_list = "\n".join([f"üöÜ {time}" for time in future_trains])
                response = f"ÿ¨ŸÖŸäÿπ ÿßŸÑŸÇÿ∑ÿßÿ±ÿßÿ™ ÿßŸÑŸÇÿßÿØŸÖÿ© ŸÖŸÜ {station} ÿ•ŸÑŸâ {destination}:\n{train_list}"
            else:
                response = f"‚ùå ŸÑÿß ŸäŸàÿ¨ÿØ ŸÇÿ∑ÿßÿ±ÿßÿ™ ŸÖÿ™ÿ®ŸÇŸäÿ© ÿßŸÑŸäŸàŸÖ ŸÖŸÜ {station} ÿ•ŸÑŸâ {destination}."
            keyboard = [[InlineKeyboardButton("‚¨ÖÔ∏è ÿßŸÑÿπŸàÿØÿ©", callback_data="back_to_start")]]
            await query.edit_message_text(text=response, reply_markup=InlineKeyboardMarkup(keyboard))
            return

        elif data.startswith("station_"):
            station = data.split("_", 1)[1]
            context.user_data["last_station"] = station
            direction = context.user_data.get("direction")
            now = get_algerian_time().time()

            def str_to_time(s):
                return datetime.strptime(s, "%H:%M").time()

            if direction == DIRECTION_GO:
                schedule = go_schedule.get(station, [])
                destination = "ÿßŸÑÿπŸÅÿ±ŸàŸÜ"
            else:
                schedule = return_schedule.get(station, [])
                destination = "ÿßŸÑÿ¨ÿ≤ÿßÿ¶ÿ±"
            next_train = next((t for t in schedule if str_to_time(t) > now), None)
            if next_train:
                response = f"üöâ ÿßŸÑŸÇÿ∑ÿßÿ± ÿßŸÑÿ¢ÿ™Ÿä ŸÖŸÜ {station} ÿ•ŸÑŸâ {destination} ŸäŸÜÿ∑ŸÑŸÇ ÿπŸÑŸâ ÿßŸÑÿ≥ÿßÿπÿ© {next_train}."
                keyboard = [
                    [InlineKeyboardButton("ÿπÿ±ÿ∂ ÿ¨ŸÖŸäÿπ ÿßŸÑŸÇÿ∑ÿßÿ±ÿßÿ™ ÿßŸÑŸÇÿßÿØŸÖÿ©", callback_data="show_all_trains")],
                    [InlineKeyboardButton("‚¨ÖÔ∏è ÿßŸÑÿπŸàÿØÿ©", callback_data="back_to_start")]
                ]
            else:
                response = f"‚ùå ŸÑÿß ŸäŸàÿ¨ÿØ ŸÇÿ∑ÿßÿ±ÿßÿ™ ŸÖÿ™ÿ®ŸÇŸäÿ© ÿßŸÑŸäŸàŸÖ ŸÖŸÜ {station} ÿ•ŸÑŸâ {destination}."
                keyboard = [[InlineKeyboardButton("‚¨ÖÔ∏è ÿßŸÑÿπŸàÿØÿ©", callback_data="back_to_start")]]
            await query.edit_message_text(text=response, reply_markup=InlineKeyboardMarkup(keyboard))
            return

        else:
            await query.edit_message_text("‚ùó ÿ£ŸÖÿ± ÿ∫Ÿäÿ± ŸÖÿπÿ±ŸàŸÅ.")
            return

    except Exception as e:
        logger.error(f"‚ùå Error in callback handler: {e}")
        logger.exception(e)
        try:
            await update.callback_query.edit_message_text("‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ÿå Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.")
        except:
            pass

def main():
    logger.info("üöÄ Starting Train Schedule Bot...")
    token = os.getenv("BOT_TOKEN")
    if not token:
        logger.error("‚ùå BOT_TOKEN not set in environment variables.")
        return
    try:
        logger.info(f"üìä MongoDB Status at startup: {'üü¢ Available' if MONGO_AVAILABLE else 'üî¥ Not Available'}")
        if MONGO_AVAILABLE and reports_collection is not None:
            try:
                count = reports_collection.count_documents({})
                logger.info(f"üìà Current reports in database: {count}")
            except Exception as e:
                logger.error(f"‚ùå Error counting documents at startup: {e}")
        app = ApplicationBuilder().token(token).build()
        app.add_handler(CommandHandler("start", start))
        app.add_handler(CommandHandler("debug", debug_db))
        app.add_handler(CallbackQueryHandler(handle_callback))
        logger.info("‚úÖ Train Schedule Bot is running with Algeria timezone and MongoDB...")
        app.run_polling()
    except Exception as e:
        logger.error(f"‚ùå Bot failed to start: {e}")
        logger.exception(e)
        raise

if __name__ == '__main__':
    main()
